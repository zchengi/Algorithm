package org.two.two.exercises;

/**
 * 2.2.13 平均情况下限。请证明任意基于。比较的排序算法的预期比较次数至少为~NlgN（假设
 * 输入元素的所有排列的出现概率是均等的）。
 * 提示：比较次数至少是比较树的外部路径的长度（根结点到所有叶子结点的路径长度之和），
 * 当树平衡时该值最小。
 *
 * @author cheng
 *         2018/1/19 16:52
 */
public class Exercise13 {
    /*
     * 对于N个元素 { a1, a2, a3, a4 ... aN } 的可能出现的所有排列方式共计N!种；
     * 比如 1 2 3 4 第一个位置有4种，第二个位置有3种，以此类推共计 4! = 24 种排列方式，
     * 所以其中 a1 < a2 < a3 < a4 ... < aN 的这种排列占总排列个数的 1 / N!；
     * 每进行一次比较，就是把最终得到的一个叶子结点划分到了 aK < aM 对应的路径，或者 aK >= aM 对应的路径下，
     * 因此可以构造出一棵基于比较的二叉树，所有叶结点都是我们最终得到的排列的一种可能，而除此外的结点代表了比较操作。
     *
     * 根据二叉树的性质，如果叶子结点有N!个，那么二叉树高度最少为logN!，此时的二叉树是满二叉树，
     * 因为从根结点到叶子结点的一条路径也就是树高代表了比较的深度，
     * 所以对于N个元素基于比较的排序算法最少比较次数为logN!。
     *
     * 因为 N! = N * (N-1) * (N-2) * ... 1 < N^N
     * 所以 log! < N * logN
     * 因为 N! = N * (N-1) * (N-2) * ... 1 > (N/2)^(N/2)
     * 所以 logN! > N/2 * log(N/2)
     * 因此 logN! 和 N * logN 的增长率相同，我们可以说基于比较的排序算法，至少需要 N * logN次比较
     */
}
