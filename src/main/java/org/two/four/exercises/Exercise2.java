package org.two.four.exercises;

/**
 * 2.4.2 分析以下说法：要实现在常数时间找到最大元素，为何不使用一个栈或队列，
 * 然后记录已插入的最大元素并找出最大元素时返回它的值？
 *
 * @author cheng
 *         2018/1/31 15:17
 */
public class Exercise2 {
    /*
     *  因为栈在删除最大值操作后，需要从零开始更新最大值；
     */

    /*
     * 栈无法保证在常数时间内找到最大值
     *
     * 假如最大值是 10，入栈顺序是 10 9 8 7 6 5 4 3 2 1
     *
     * 我们知道，栈是后进先出的数据结构，因此，即便我们知道最大值是10，我们也需要把 10 之前的所有元素都
     * 弹出，才能得到它
     * 换个角度，如果入栈顺序是 9 8 7 6 5 4 3 2 1 10
     * 我们知道，最大值是10，并且也仅需要一步操作，就可以将最大值弹出，但是接下来，我们需要弹出当前栈空间
     * 的最大值，第一，我们没有记录过这个最大值，因为最大值的记录会随着每次入栈操作而更新，
     * 因此我们仅仅只能弹出一次最大值，而不能弹出“当前栈中的最大值”
     *
     * 队列也无法保证在常数时间内找到最大值
     *
     * 假如最大值是10，入对顺序是 0 1 2 3 4 5 6 7 8 9 10
     *
     * 我们知道，队列是先进先出的数据结构，因此，即便我们知道最大值是10，我们也需要把 10 之前的所有元素都
     * 出队，才轮得到弹出它
     * 并且，我们同样无法得到第二大元素，第三大元素，以及第 k 大元素的记录
     *
     */
}
